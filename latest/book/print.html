<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="highlight.css">

        <link rel="stylesheet" href="static/css/cymbalum.css">

        <!-- MathJax -->
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });</script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="engine/intro.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="engine/system.html"><strong>1.1.</strong> System</a></li><li><a href="engine/simulation.html"><strong>1.2.</strong> Simulation</a></li></ul></li><li><strong>2.</strong> Tutorial: using Cymbalum</li><li><ul class="section"><li><strong>2.1.</strong> Monte-Carlo of argon</li><li><strong>2.2.</strong> Molecular dynamics of water</li><li><strong>2.3.</strong> Gibbs simulation of ethane</li><li><strong>2.4.</strong> Hello Sodium Chloride</li><li><strong>2.5.</strong> Adsorption in zeolites</li></ul></li><li><a href="input/intro.html"><strong>3.</strong> Input files</a></li><li><ul class="section"><li><a href="input/systems.html"><strong>3.1.</strong> Systems</a></li><li><a href="input/interactions.html"><strong>3.2.</strong> Interactions</a></li><li><a href="input/potentials.html"><strong>3.3.</strong> Potentials</a></li><li><a href="input/simulations.html"><strong>3.4.</strong> Simulations</a></li><li><a href="input/md.html"><strong>3.5.</strong> Molecular dynamics</a></li><li><a href="input/mc.html"><strong>3.6.</strong> Monte-Carlo</a></li><li><a href="input/units.html"><strong>3.7.</strong> Units</a></li></ul></li><li><strong>4.</strong> Tutorial: extending Cymbalum</li><li><ul class="section"><li><strong>4.1.</strong> Adding potentials</li><li><strong>4.2.</strong> Adding outputs</li><li><strong>4.3.</strong> Extending Molecular dynamics</li><li><strong>4.4.</strong> Extending Monte-Carlo</li><li><strong>4.5.</strong> Adding propagators</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Welcome to Cymbalum user manual!</h1>
<p>Cymbalum is a flexible and extensible molecular simulation engine. That means:</p>
<ul>
<li>You can use it to drive classical molecular simulations; from Monte-Carlo to
molecular dynamics and energy minimization;</li>
<li>You have full control over the simulation steps, and the simulated system;</li>
<li>You can <em>easily</em> extend the engine with new algorithms, and hook into its
internals.</li>
</ul>
<p>This user manual describes how to use Cymbalum either as a command line tool or
a library.</p>
<h2>Systems and Simulations</h2>
<p>The two main concepts in Cymbalum are a <code>System</code> and a <code>Simulation</code>. A <code>System</code>
contains all the simulated system data: atomic names, positions and velocities,
force-field, simulation box. On the other hand, a <code>Simulation</code> contains
everything needed to run a simulation with a system, <em>i.e.</em> algorithms and
associated data.</p>
<p>A <code>System</code> is usually used in combination with one <code>Simulation</code> to explore the
properties of the system. Sometimes multiple systems can be associated with the
same simulation (in Gibbs ensemble Monte-Carlo or in parallel tempering); and
sometimes multiple simulations can be associated with the same system, when
running an energy minimization before a molecular dynamics run.</p>
<h1>System</h1>
<p>A <code>System</code> contains all the data about the physical system we are simulating.
It contains four types of data:</p>
<ul>
<li>A list of <strong>Particles</strong>, which are physical objects, with a position, a
velocity, a mass and a name;</li>
<li>A list of <strong>Molecules</strong> containing information about how the particles are
bounded together;</li>
<li>An <strong>UnitCell</strong>, <em>i.e.</em> the bounding box of the simulation.</li>
<li><strong>Interactions</strong>, sometimes called a force-field.</li>
</ul>
<p><img src="static/img/system.svg#center" alt="System components" /></p>
<h2>Unit cells</h2>
<p>Cymbalum knows about three types of unit cells:</p>
<ul>
<li>Infinite cells do not have any boundaries, and can be used to simulate
systems in vacuum;</li>
<li>Orthorhombic cells have up to three independent lengths, and all the angles
of the cell are set to 90°;</li>
<li>Triclinic cells have 6 independent parameters: 3 lengths and 3 angles.</li>
</ul>
<p>Orthorhombic and Triclinic cells are used in combination with <a href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">periodic boundary
conditions</a> to
simulate infinite systems.</p>
<h2>Interactions</h2>
<p>Interactions associate a potential and some particles kind. Cymbalum provides
code for various potentials types:</p>
<ul>
<li>Non-bonding pair potentials;</li>
<li>Bonds potentials in molecules;</li>
<li>Angles potentials in molecules;</li>
<li>Dihedral angles potentials in molecules;</li>
<li>Long-ranges coulombic potentials (Ewald and Wolf methods);</li>
<li>Arbitrary external potential applying on the whole system at once.</li>
</ul>
<h1>Simulation</h1>
<p>The flow of a simulation in Cymbalum is represented below.</p>
<p><img src="static/img/simulation.svg#center" alt="Simulation flow graph" /></p>
<p>First, it uses a system to setup any algorithms which uses system specific
informations.</p>
<p>Then it propagate the system for one step, compute the physical properties as
needed, and output these properties to the hard drive.</p>
<p>If the simulation is finished (either the required number of steps has been
done, or come convergence criterion is reached) it returns the updated system.
If the simulation is not finished, the system is propagated for one more step.</p>
<h2>Propagators</h2>
<p>Propagators are at the heart of a Simulation. They have the responsibility to
update the system at each simulation step. Currently, three propagators exists:
a molecular dynamics one, a Monte-Carlo one and a minimizer, for energy
minimization.</p>
<h1>Input files</h1>
<p>Cymbalum input files uses the <a href="https://github.com/toml-lang/toml">TOML</a> format, a simple and minimalist
configuration format based on <code>key = value</code> pairs. You can read an introduction
to the TOML format <a href="https://github.com/toml-lang/toml">here</a>.</p>
<p>The input file describe everything needed for running a simulation: which system
to use, with which force field, and how to propagate the simulation. They
usually contain three main sections:</p>
<ul>
<li>The <a href="input/intro.html#Input%20metadata">input</a> section describe metadata about
the input itself;</li>
<li>The <a href="input/systems.html">systems</a> section describe the system to use in the
simulation;</li>
<li>The <a href="input/simulations.html">simulations</a> section describe how to update the
system during the simulation;</li>
</ul>
<p>Interactions between particles in the system are a bit special: they can either
be specified in they own input file (to be reused in multiple simulations); or
be part of the <code>[[systems]]</code> section. This <a href="input/interactions.html">page</a>
describe the standalone input for interactions.</p>
<h2>Input metadata</h2>
<p>All input files must contain an <code>[input]</code> section looking like this:</p>
<pre><code class="language-toml">[input]
version = 1
</code></pre>
<p>The purpose of the <code>version</code> key is to make changes to the input file format,
while keeping compatibility with the previous input format. Please note that
while Cymbalum have not reach version 1.0, no guarantee is made on input file
compatibility.</p>
<h2>Units in input</h2>
<p>The unit of a value can be defined by a specific string, which will be parsed
and converted to the <a href="input/units.html">internal unit system</a>.
If there is no unit in the string, the internal unit for this type is used.
No consistency check is performed, and it is up to the code users to check the
given units.</p>
<pre><code class="language-toml"># Here, 'cutoff' is a distance

# OK
cutoff = &quot;8 A&quot;
# OK, will use the internal unit of distance.
# This is not recommended. The internal unit may change, and the input convey less information
cutoff = &quot;8&quot;    
# OK, but big !
cutoff = &quot;8 km&quot;  

# OK, but probably not what you want. Will be interpreted as 8000 A
cutoff = &quot;8 ps&quot;
# invalid, 'cutoff' must be a string
cutoff = 8.0   
</code></pre>
<h1>Systems</h1>
<p>The system to use in a simulation must be specified in the <code>[[systems]]</code> section
of the input file. The minimal input file contains only the <code>file</code> key, giving
the path to a file to read to get the system.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;data/CO2.pdb&quot;
</code></pre>
<p>The program read the file, and use information from this file to build the
system. If the file is a trajectory containing multiple steps, the first frame
is used. File reading is provided by <a href="http://chemfiles.github.io/">chemfiles</a>,
and supported formats are documented <a href="http://chemfiles.readthedocs.io/en/latest/formats.html">here</a>.</p>
<p>Additional keys allow to change the system after it is read from the file.</p>
<h2>Setting the topology</h2>
<p>When using a simple <code>.xyz</code> file as the system definition, no bonding information
are present in the system. There are two ways to add bonding informations:</p>
<ul>
<li>Use the <code>topology</code> key to give a file containing topological informations
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
topology = &quot;topology.pdb&quot;
</code></pre>
</li>
<li>Use the <code>guess_bonds</code> key, to use a distance-based algorithm to guess the
bonds in the system. The algorithm used is the same as the one in <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>.
You should always check if the bonding informations guessed by the algorithm
is coherent with your system.
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
guess_bonds = true
</code></pre>
</li>
</ul>
<h2>Setting the unit cell</h2>
<p>The <code>cell</code> key can be used to set the unit cell of the system in three different
ways:</p>
<ul>
<li><code>cell = &lt;length&gt;</code> will set the unit cell to a cubic cell with the given side
length. <code>&lt;length&gt;</code> should be a numeric value in Angstrom.
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
cell = 40
</code></pre>
</li>
<li><code>cell = [&lt;a&gt;, &lt;b&gt;, &lt;c&gt;]</code> will set the unit cell to a orthorhombic cell with<br />
the given side lengths. <code>&lt;a&gt;</code>, <code>&lt;b&gt;</code>, and <code>&lt;c&gt;</code> should be numeric values in
Angstrom.
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
cell = [24, 24, 76]
</code></pre>
</li>
<li><code>cell = [&lt;a&gt;, &lt;b&gt;, &lt;c&gt;, &lt;alpha&gt;, &lt;beta&gt;, &lt;gamma&gt;]</code> will set the unit cell to a
triclinic cell with the given side lengths and angles. <code>&lt;a&gt;</code>, <code>&lt;b&gt;</code>, and <code>&lt;c&gt;</code>
should be numeric values in Angstrom; and <code>&lt;alpha&gt;</code>, <code>&lt;beta&gt;</code>, and <code>&lt;gamma&gt;</code>
numeric values in degree.
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
cell = [24, 24, 22, 90, 82.33, 110.4]
</code></pre>
</li>
</ul>
<h2>Initializing velocities</h2>
<p>For molecular dynamics simulations, the <code>velocities</code> key can be used to
initialize the velocities in the system. The syntax is the following:</p>
<pre><code class="language-toml">[[systems]]
file = &quot;data/CO2.pdb&quot;
velocities = {init = &quot;300 K&quot;}
</code></pre>
<p>Where <code>init</code> key refers to a temperature string. The velocities will the be
initialized from a Boltzmann distribution at this temperature.</p>
<h2>Specifying interactions</h2>
<p>Interactions between atoms can be specified in two ways: either inside the main
input file, or as a separated file.</p>
<p>If the <code>potentials</code> key contains a string, this string is interpreted as the
path to another input file containing only interactions definitions, as
documented <a href="input/interactions.html">here</a>.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;polymer.pdb&quot;
potentials = &quot;potentials.toml&quot;
</code></pre>
<p>If the <code>potentials</code> key is actually a sub-table of <code>systems</code>, then the different
sections for interactions input (<code>pairs</code>, <code>charges</code>, <code>angles</code>, ...) are looked
inside this table. They use the same syntax as in <a href="input/interactions.html">standalone
input</a>.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;polymer.pdb&quot;

[[systems.potentials.pairs]]
atoms = [&quot;C&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;0.5 kJ/mol&quot;}

[[systems.potentials.angles]]
atoms = [&quot;O&quot;, &quot;C&quot;, &quot;O&quot;]
harmonic = {x0 = &quot;109 deg&quot;, k = &quot;5 kJ/mol/deg&quot;}
</code></pre>
<h1>Interactions</h1>
<p>An interaction is the association of atomic types, a potential function and
optionally restrictions and mode of computation. Input files for interaction
contains all this information, ordered in multiple sections. The <code>pairs</code>,
<code>bonds</code>, <code>angles</code> and <code>dihedrals</code> sections are arrays of interactions, listing
possible atomic combinations and associated potentials. The <code>coulomb</code> section
contains information about the treatment of long-range electrostatic
interactions, and the <code>charges</code> section defines the partial charges of the
atoms.</p>
<p>An example of an input file for the f-SPC model of water is given bellow:</p>
<pre><code class="language-toml">[input]
version = 1

[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3.16 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}

[[pairs]]
atoms = [&quot;O&quot;, &quot;H&quot;]
null = {}

[[pairs]]
atoms = [&quot;H&quot;, &quot;H&quot;]
harmonic = {k = &quot;79.8 kcal/mol/A^2&quot;, x0 = &quot;1.633 A&quot;}
restriction = &quot;intra-molecular&quot;

[[bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1054.2 kcal/mol/A^2&quot;, x0 = &quot;1.0 A&quot;}

[[angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.9 kcal/mol/rad^2&quot;, x0 = &quot;109.5 deg&quot;}

[coulomb]
ewald = {cutoff = &quot;10 A&quot;, kmax = 7}

[charges]
O = -0.82
H = 0.41
</code></pre>
<h2>Pairs and molecular interactions</h2>
<p>The <code>pairs</code>, <code>bonds</code>, <code>angles</code> and <code>dihedrals</code> sections are arrays, in which
every entry must contain at least two keys: the <code>atoms</code> key, and a
<a href="input/potentials.html#Available%20potentials">potential</a> key. The <code>atoms</code> key
specifies the atom types to which the interaction should be applied and should
contain two atoms for <code>pairs</code> and <code>bonds</code>, three atoms for <code>angles</code> and four
atoms for <code>dihedrals</code>.</p>
<p>For example, to use a harmonic bond potential for all <code>C-H</code> bonds:</p>
<pre><code class="language-toml">[[bonds]]
atoms = [&quot;C&quot;, &quot;H&quot;]
harmonic = {x0 = &quot;3.405 A&quot;, k = &quot;2385 kcal/mol/A^2&quot;}
</code></pre>
<p>It is also possible in the <code>pairs</code> section to specify an additional
<a href="input/potentials.html#Restrictions">restriction</a> using the <code>restriction</code> key;
or a <a href="input/potentials.html#Potential%20computations">computation method</a> using
the <code>computation</code> key.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;Ar&quot;, &quot;Ar&quot;]
lj = {sigma = &quot;3.405 A&quot;, epsilon = &quot;0.2385 kcal/mol&quot;}
computation = {table = {n = 2000, max = &quot;20.0 A&quot;}}
restriction  = &quot;IntraMolecular&quot;
</code></pre>
<h2>Coulombic interactions</h2>
<p>The method for treatment of electrostatic interactions is specified in the
<code>coulomb</code> section. There are multiple available solvers for <a href="input/potentials.html#Electrostatic%20interactions">electrostatic
interactions</a>. Optionally,
an additional <a href="input/potentials.html#Restrictions">restriction</a> can be specified
with the <code>restriction</code> key.</p>
<pre><code class="language-toml">[coulomb]
ewald = {cutoff = &quot;10 A&quot;, kmax = 7}
restriction  = &quot;exclude13&quot;

[charges]
Na = 1
Cl = -1
</code></pre>
<h1>Available potentials</h1>
<p>This section is a list of all the available potentials in Cymbalum, with the
associated parameters. All potentials have to provide additional parameters in
there definition, as a TOML table. Using inline tables is the easiest way to do
so:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;A&quot;, &quot;B&quot;]
# Additional parameters here are 'sigma' and 'epsilon'.
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
</code></pre>
<p>The same potential can be used for either pairs (at distance $r$); or for
angles (at angle $\phi$). In all the formulas, the $x$ parameter
represents either a distance or an angle.</p>
<h2>Null potential</h2>
<p>This potential is always 0, for all values of $x$. It should be used to remove
interactions between atoms in a pair/bond/angle/dihedral that are
present in the system but should not be interacting.</p>
<p>This potential can be used by specifying the <code>null</code> key with an empty table <code>{}</code>
as value.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
null = {}
</code></pre>
<h2>Lennard-Jones potential</h2>
<p>The Lennard-Jones potential is a classical potential for pair interactions
expressed as: $$ V(x) = 4 \epsilon \left[\left(\frac{\sigma}{x}\right)^{12} -
\left(\frac{\sigma}{x}\right)^6\right].$$</p>
<p>The Lennard-Jones potential is defined using the <code>lj</code> or <code>lennardjones</code> key. The
parameters are <code>sigma</code> ($\sigma$) and <code>epsilon</code> ($\epsilon$), which should be
provided as strings.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lennardjones = {sigma = &quot;3.16 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}
</code></pre>
<h2>Harmonic potential</h2>
<p>The Harmonic potential is usually used for intramolecular interactions such as
bonds, angles or dihedrals. It is expressed as:
$$ V(x) = \frac 12 k \ (x - x_0)^2$$</p>
<p>The potential type keyword is <code>harmonic</code>, and the parameters are <code>k</code> and <code>x0</code>,
provided as strings.</p>
<pre><code class="language-toml">[[bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1054.2 kcal/mol/A^2&quot;, x0 = &quot;1.0 A&quot;}

[[angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.9 kcal/mol/rad^2&quot;, x0 = &quot;109.5 deg&quot;}
</code></pre>
<h2>Cosine-Harmonic potential</h2>
<p>This potential is usually used for angles and dihedral angles interactions,
because it presents a $2\pi$ periodicity. It is expressed as: $$ V(x) = \frac 12
k \ (\cos x - \cos x_0)^2$$</p>
<p>The potential type keyword is <code>cosine-harmonic</code>, and the parameters <code>k</code> and <code>x0</code>
should be provided as strings.</p>
<pre><code class="language-toml">[[angles]]
atoms = [&quot;H&quot;, &quot;C&quot;, &quot;H&quot;]
cosine-harmonic = {k = &quot;67 kJ/mol&quot;, x0 = &quot;120 deg&quot;}
</code></pre>
<h2>Torsion potential</h2>
<p>This potential is usually used for dihedral interactions. It is
expressed as: $$ V(x) = k \ (1 + \cos(n x - \delta))$$</p>
<p>The potential type keyword is <code>torsion</code>, and the parameters <code>k</code> and <code>delta</code>
($\delta$) should be provided as strings, and <code>n</code> should be provided as an
integer.</p>
<pre><code class="language-toml">[[dihedrals]]
atoms = [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;]
torsion = {k = &quot;40 kJ/mol&quot;, delta = &quot;120 deg&quot;, n: 4}
</code></pre>
<h1>Electrostatic interactions</h1>
<p>When some particles in a system are charged, they interact with a Coulomb
potential: $$ V(x) = \frac{Z_i Z_j}{4 \pi \epsilon r_{ij}}, $$ where $Z_{i,j}$
are the net charges of the particles, $r_{ij}$ the distance between them and
$\epsilon$ the dielectric permittivity of the current medium (usually the one of
void). Because this potential goes to zero at infinity slower than $1/r^3$, it
can not be computed in periodic simulations using a cutoff distance. This
section present the available solvers for electrostatic interactions.</p>
<p>In the input files, electrostatic interactions are specified with two sections:
the <code>[charges]</code> section set the values of the charges of the atoms in the
system, and the <code>[coulomb]</code> section set the solver to use for the interaction.</p>
<h2>Charge section</h2>
<p>Charges for the particles in the system are set in a <code>[charges]</code> section in the
potential input file. This section should contains multiple <code>name = &lt;charge&gt;</code>
entries, one for each charged particle in the system.</p>
<pre><code class="language-toml"># Some salt here
[charges]
Na = 1
Cl = -1
</code></pre>
<h2>Ewald solver</h2>
<p>Ewald idea for computing the electrostatic interactions is to split the
interaction in a short-range term which can be handled with a cutoff scheme; and
a long range term that ca be computed by using a <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier
transform</a>. For more
information about the Ewald summation and its variants, see
<a href="http://dx.doi.org/10.1063/1.881812">[Frenkel2002]</a>.</p>
<p>The <code>[coulomb]</code> section for using an Ewald solver looks like this in the input
file:</p>
<pre><code class="language-toml">[coulomb]
ewald = {cutoff = &quot;9 A&quot;, kmax = 7}
</code></pre>
<p>The <code>cutoff</code> parameter specify the cutoff distance for the short-range and
long-range interactions splitting. The <code>kmax</code> parameter give the number of
vector to use in the reciprocal space (the long-range part of interactions).
Usually 7-8 is a good value for pure water, for very periodic charges a lower
value like 5 can do it, and for more heterogeneous system, higher values of
<code>kmax</code> are needed.</p>
<h2>Wolf solver</h2>
<p>Wolf method is another method for computing electrostatic interactions presented
in <a href="http://dx.doi.org/10.1063/1.478738">[Wolf1999]</a>. This method replaces the
expensive computation in reciprocal space from Ewald by a corrective term, and
can be expressed as a converging sum over the charged pairs in the system.</p>
<p>It is accessible with the <code>wolf</code> keyword in the input files:</p>
<pre><code class="language-toml">[coulomb]
wolf = {cutoff = &quot;11 A&quot;}
</code></pre>
<p>The only parameter is a <code>cutoff</code>, which should be taken bigger than the
corresponding Ewald cutoff. A value of 10 A is a good one in pure water.</p>
<h1>Restrictions</h1>
<p>Some force fields define additional restrictions concerning which particles
should interact together. For example, sometimes bonded particles should not
interact through electrostatic potential, or some interactions should only be
taken in account for particles not in the same molecule. The way to specify this
is to use restrictions. Restrictions can be used in two places: in the
<code>[[pairs]]</code> section, and in the <code>[coulomb]</code> section. In both cases, they are
specified with the <code>restriction</code> keyword, and one of the possible values.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
restriction = {scale14 = 0.5}

[coulomb]
ewald = {cutoff = &quot;8 A&quot;, kmax = 6}
restriction = &quot;intermolecular&quot;
</code></pre>
<p>The possible values for <code>restriction</code> are:</p>
<ul>
<li><code>&quot;intramolecular&quot;</code> or <code>&quot;intra-molecular&quot;</code> to restrict the potential to only
particles in the same molecule;</li>
<li><code>&quot;intermolecular&quot;</code> or <code>&quot;inter-molecular&quot;</code> to restrict the potential to only
particles NOT in the same molecule;</li>
<li><code>&quot;exclude12&quot;</code> to exclude particles directly bonded together;</li>
<li><code>&quot;exclude13&quot;</code> to exclude particles directly bonded together or forming an
angle;</li>
<li><code>&quot;exclude14&quot;</code> to exclude particles directly bonded together; forming an angle
or a dihedral angle;</li>
<li><code>{scale14 = &lt;scaling&gt;}</code> to exclude particles directly bonded together or
forming an angle and to scale interaction between particles at 3 bonds of
distance by the given <code>scaling</code> factor. The factor must be between 0 and 1.</li>
</ul>
<h1>Potential computations</h1>
<p>The same potential function (Lennard-Jones, Harmonic, <em>etc.</em>) can be computed
with different method: directly, by sifting it at the cutoff distance, using a
table interpolation, <em>etc.</em> This is the purpose of computation. The default way
is to use the mathematical function corresponding to a potential to compute it.
To use another computation, the <code>computation</code> keyword can be used in the
<code>[[pairs]]</code> section.</p>
<h2>Cutoff computation</h2>
<p>It is possible to use a cutoff radius $rc$ to compute a potential $U(r)$ such
that:</p>
<p>$$ V(r) = \begin{cases}
U(r) - U(rc) &amp; r &lt;= rc \\
0 &amp; r &gt; rc
\end{cases}$$</p>
<p>The potential $U$ is additionally shifted to make sure it is continuous at $r =
rc$. This is important for molecular dynamics, where a discontinuity means an
infinite force in the integration.</p>
<p>You can choose the <code>cutoff</code> by providing it in the input:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
computation = {cutoff = &quot;8 A&quot;}
</code></pre>
<h2>Table interpolation</h2>
<p>Another way to compute a potential is to pre-compute it on a regularly spaced
grid, and then to interpolate values for points in the grid. In some cases, this
can be faster than recomputing the function every time.</p>
<p>This can be done with the <code>table</code> computation, which does a linear interpolation
in regularly spaced values in the <code>[0, max)</code> segment. You need to provide the
<code>max</code> value, and the number of points <code>n</code> for the interpolation:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
computation = {table = {max = &quot;8 A&quot;, n = 5000}}
</code></pre>
<hr />
<p>[Frenkel2002] Frenkel, D. &amp; Smit, B. <em>Understanding molecular simulation.</em>
(Academic press, 2002).</p>
<p>[Wolf1999] Wolf, D., Keblinski, P., Phillpot, S. R. &amp; Eggebrecht, J. <em>Exact
method for the simulation of Coulombic systems by spherically truncated,
pairwise 1/r summation.</em> The Journal of Chemical Physics <strong>110</strong>, 8254 (1999).</p>
<h1>Simulations</h1>
<p>The way to propagate the system is defined in the <code>[[simulations]]</code> section of
the input file. This section always contains at least two keys: <code>nsteps</code> specify
the number of steps in the simulation, and the <code>simulations.propagator</code> table
specify which propagator to use.</p>
<p>Here is an example of NPT molecular dynamics:</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000

[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>Two propagators are currently implemented: one for <a href="input/md.html">molecular dynamics</a>; and
one for <a href="input/mc.html">Monte-Carlo</a>.</p>
<h2>Outputs</h2>
<p>Additionally, a simulation can also output the evolution of the system
properties. Which properties are needed is given in the <code>outputs</code> array:</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000
outputs = [
    {type = &quot;Trajectory&quot;, file = &quot;filename.xyz&quot;, frequency = 100},
    {type = &quot;Energy&quot;, file = &quot;energy.dat&quot;, frequency = 200}
]

[simulations.propagator]
...
</code></pre>
<p>This array is an array of tables, containing three keys: the <code>type</code> of output,
the <code>file</code> to write the output to; and the <code>frequency</code> of the output. The file
is a path, and the output will be written to this path. The frequency is a
number, and the output will be written every <code>frequency</code> steps to the file.
Except for the <code>Trajectory</code> output, all files are formatted with header lines
starting with a <code>#</code>, and containing information about the quantities and the
units used for the output, and then multiple lines containing the step and the
quantities. The available outputs are the following:</p>
<ul>
<li>The <code>Energy</code> output will write the potential, kinetic and total energy;</li>
<li>The <code>Cell</code> output will write the unit cell parameters, lengths and angles;</li>
<li>The <code>Properties</code> output will write the volume, the instant pressure (computed
from the virial equation) and the instant temperature of the system;</li>
<li>The <code>Trajectory</code> output should be used to write a trajectory. The format of
the trajectory will be guessed from the <code>file</code> extension. Supported formats
are documented in <a href="http://chemfiles.github.io/chemfiles/">chemfiles</a>
documentation.</li>
</ul>
<h1>Molecular dynamics</h1>
<p>A molecular dynamics simulation is started by setting the propagator <code>type</code> to
<code>&quot;MolecularDynamics&quot;</code>. The only needed key is the <code>timestep</code>, which is the
time step to use in the integration of forces and velocities to positions.</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000

[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>Other options are the <code>integrator</code> key to use another integration scheme, the
<code>thermostat</code> key to set a thermostat, and the <code>controls</code> key to add some
additional control algorithm to the simulation.</p>
<h2>Integrators</h2>
<p>Integrators are algorithms that propagate the forces acting on the particles to
compute their motions. The simplest ones performs an NVE integration, but some
integrators allow to work in different ensembles. All NVE integrators can be
turned into NVT integrators by adding a <a href="input/md.html#Thermostats">thermostat</a>
to the simulation. In the input, if the <code>integrator</code> key is absent, the default
integrator is a Velocity-Verlet integrator.</p>
<h3>Velocity-Verlet integrator</h3>
<p>Velocity-Verlet is the most common NVE integrator for molecular dynamics. See
this <a href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">page</a> for more informations about the algorithm.</p>
<p>In the input, it can be specified by using the <code>VelocityVerlet</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;VelocityVerlet&quot;}
</code></pre>
<h3>Verlet integrator</h3>
<p>Verlet algorithm is another simple NVE integrator. See this <a href="https://en.wikipedia.org/wiki/Verlet_integration#Basic_St.C3.B6rmer.E2.80.93Verlet">page</a> for
more informations. Most of the time, the Velocity-Verlet algorithm is
preferable, since it produces more precise velocities.</p>
<p>In the input, it can be specified by using the <code>Verlet</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;Verlet&quot;}
</code></pre>
<h3>Leap-Frog integrator</h3>
<p>The Leap-Frog algorithm is a third NVE integrator. See this <a href="https://en.wikipedia.org/wiki/Leapfrog_integration">page</a> for
details about the algorithm.</p>
<p>In the input, it can be specified by using the <code>LeapFrog</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;LeapFrog&quot;}
</code></pre>
<h3>Berendsen barostat</h3>
<p>The Berendsen barostat integrator algorithm use the Berendsen barostat with a
Velocity-Verlet integrator to achieve NPT integration. It must be use together
with a thermostat, preferentially the Berendsen thermostat. See this
<a href="http://www.sklogwiki.org/SklogWiki/index.php/Berendsen_barostat">page</a> for more informations about the algorithm.</p>
<p>This algorithm exists in two versions: an isotropic one and an anisotropic one.
The isotropic version of the barostat scale all the cell parameter by the same
value using the scalar pressure. The anisotropic version scale the different
cell parameters by different values, using the stress tensor instead.</p>
<p>In the input, the isotropic barostat can be specified by using the
<code>BerendsenBarostat</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The <code>pressure</code> key specify the target pressure for the simulation, and the
<code>timestep</code> is the relaxation time step of the barostat.</p>
<p>The anisotropic barostat can be specified by using the <code>AnisoBerendsenBarostat</code>
integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;AnisoBerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The <code>pressure</code> key specify the target hydrostatic pressure for the simulation,
and the <code>timestep</code> is the relaxation time step of the barostat.</p>
<p>In both cases, the barostat time step is expressed in fraction of the main
integration time step. Using a main time step of 2 fs and a barostat time step
of 1000 will yield an effective relaxation time of 2000 fs or 2 ps.</p>
<h2>Thermostats</h2>
<p>Thermostats are algorithms used to maintain the temperature of a system at a
given value. They are specified in the input by the <code>thermostat</code> key.</p>
<h3>Berendsen thermostat</h3>
<p>The Berendsen barostat is described <a href="http://www.sklogwiki.org/SklogWiki/index.php/Berendsen_thermostat">here</a>, and provide a
simple exponential relaxation of the temperature to a target value. In the
input, it is declared with the <code>Berendsen</code> thermostat type, a target
<code>temperature</code> value, and a <code>timestep</code>.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The time step is expressed in fraction of the main integration time step, like
for the Berendsen barostat.</p>
<h3>Rescaling thermostat</h3>
<p>A rescaling thermostat is the simplest thermostating algorithm possible: it just
rescale all the velocities to set the temperature to the wanted value. It can be
useful for equilibrations, for a fast convergence. In the input, it is specified
by the <code>Rescale</code> thermostat type, a target <code>temperature</code> value, and a
<code>tolerance</code> value. The tolerance value is optional, and is used to let the
system fluctuate around the wanted temperature: while the instant temperature is
inside the <code>[temperature - tolerance : temperature + tolerance]</code> range, no
rescale happen.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
thermostat = {type = &quot;Rescale&quot;, temperature = &quot;250 K&quot;, tolerance = &quot;10 K&quot;}
</code></pre>
<h2>Controls</h2>
<p>Control algorithm are supplementary steps that modify the system to ensure some
invariant, or apply some constraint. They are specified in the <code>controls</code> array,
by giving a control <code>type</code>.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
controls = [
    {type = &quot;RemoveRotation&quot;}
]
</code></pre>
<ul>
<li>The <code>RemoveTranslation</code> control remove the global system rotation;</li>
<li>The <code>RemoveRotation</code> control remove the global system translation.</li>
</ul>
<h1>Monte-Carlo</h1>
<p>A Monte-Carlo simulation is started by setting the propagator <code>type</code> to
<code>MonteCarlo</code>. The two needed keys are the <code>temperature</code> of the simulation, and
the Monte-Carlo <code>moves</code> to use.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;1 A&quot;, frequency = 2},
    {type = &quot;Rotate&quot;, delta = &quot;20 deg&quot;, molecule = &quot;CO2.xyz&quot;},
]
</code></pre>
<h2>Moves</h2>
<p>All the Monte-Carlo moves are specified as inline tables, with the <code>type</code> key
setting the type of move. They all accept an optional <code>frequency</code> value setting
at which frequency the move should be selected. By default the frequency is 1,
and the actual frequency will be the <code>frequency</code> value diveded by the sum of all
the frequencies.</p>
<p>Some moves acting a single molecule also accept a <code>molecule</code> key, giving the
path to a file which <a href="chemfiles.github.io">chemfiles</a> can read. The molecule associated
with the move will then be selected with the following algorithm:</p>
<ul>
<li>Read the first frame of the file;</li>
<li>If the file does not contain any bonding informations, try to guess the bonds;</li>
<li>Use the first molecule of the frame.</li>
</ul>
<p>The same move type can be present more than once in the input, to have different
amplitudes for different compounds for example.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;2 A&quot;, molecule = &quot;H2O.xyz&quot;},
    {type = &quot;Translate&quot;, delta = &quot;0.5 A&quot;, molecule = &quot;protein.pdb&quot;},
]
</code></pre>
<h3>Translation</h3>
<p>The <code>Translate</code> move type will do small translations of a single molecule at the
time. If the input contains the <code>molecule</code> key, the move will only apply to one
molecule. If not, the move will apply to all molecules in the system. The
<code>delta</code> key gives the amplitude of the translations, in distance unit.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;1 A&quot;, frequency = 2},
    {type = &quot;Translate&quot;, delta = &quot;10 A&quot;, molecule = &quot;He.xyz&quot;},
]
</code></pre>
<h3>Rotation</h3>
<p>The <code>Rotate</code> move type will do small rotations of a single molecule at the
time. If the input contains the <code>molecule</code> key, the move will only apply to one
molecule. If not, the move will apply to all molecules in the system. The
<code>delta</code> key gives the amplitude of the rotations, in angle unit.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Rotate&quot;, delta = &quot;3 deg&quot;, frequency = 2},
]
</code></pre>
<h1>Units</h1>
<p>Cymbalum features a set of internal units and offers facilities to convert
from and to this set of internal units.</p>
<p>The internal unit system is the following:</p>
<ul>
<li>Angstrom (<code>A</code>) for distances;</li>
<li>Femto-second (<code>fs</code>) for time;</li>
<li>Unified atomic mass unit (<code>u</code> or <code>Da</code>) for mass;</li>
<li>Kelvin (<code>K</code>) for temperature;</li>
<li>Number of particles for quantity of matter;</li>
<li>Radian (<code>rad</code>) for angles;</li>
</ul>
<p>Any other internal unit is derived from this set:</p>
<ul>
<li>The internal unit of energy is <code>u A^2 fs^-2</code>;</li>
<li>The internal unit of force is <code>u A fs^-2</code>;</li>
<li>The internal unit of pressure is <code>u A^-1 fs^-2</code>;</li>
<li><em>etc.</em></li>
</ul>
<p>Cymbalum knows how to convert any value in these internal unit to others units.
The accepted units are:</p>
<table><thead><tr><td> Quantity    </td><td> Accepted units                    </td></tr></thead>
<tr><td> Distance    </td><td> A, Å, nm, pm, fm, m, bohr   </td></tr>
<tr><td> Time        </td><td> fs, ps, ns                        </td></tr>
<tr><td> Mass        </td><td> u, Da, kDa, g, kg                 </td></tr>
<tr><td> Matter      </td><td> mol                               </td></tr>
<tr><td> Angle       </td><td> rad, deg                          </td></tr>
<tr><td> Energy      </td><td> J, kJ, kcal, eV, H, Ry            </td></tr>
<tr><td> Force       </td><td> N                                 </td></tr>
<tr><td> Pressure    </td><td> Pa, kPa, MPa, bar, atm            </td></tr>
</table>
<p>In the input files, the units are specified as strings, and must be spelled
exactly as in the above table. They can be combined with other units using <code>*</code>
for multiplication, <code>/</code> for division, and  <code>^</code> for exponents. Parentheses can be
used to group sub-units together. Some valid unit strings are <code>kcal/mol</code>, <code>(J / mol) * A^-2</code>, and <code>m*fs^-1</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
