<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="highlight.css">

        <link rel="stylesheet" href="static/css/lumol.css">

        <!-- MathJax -->
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });</script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="installation.html"><strong>2.</strong> Installation</a></li><li><a href="tutorial/intro.html"><strong>3.</strong> First simulations</a></li><li><ul class="section"><li><a href="tutorial/argon.html"><strong>3.1.</strong> Monte-Carlo of Argon</a></li><li><a href="tutorial/nacl.html"><strong>3.2.</strong> Hello Sodium Chloride</a></li><li><a href="tutorial/water.html"><strong>3.3.</strong> Molecular dynamics of water</a></li><li><strong>3.4.</strong> Gibbs simulation of ethane</li><li><strong>3.5.</strong> Adsorption in zeolites</li></ul></li><li><strong>4.</strong> Conceptual guides</li><li><ul class="section"><li><a href="concepts/system.html"><strong>4.1.</strong> System</a></li><li><a href="concepts/simulation.html"><strong>4.2.</strong> Simulation</a></li><li><a href="concepts/units.html"><strong>4.3.</strong> Units</a></li></ul></li><li><a href="input/intro.html"><strong>5.</strong> Input files</a></li><li><ul class="section"><li><strong>5.1.</strong> TOML syntax</li><li><a href="input/systems.html"><strong>5.2.</strong> Systems</a></li><li><a href="input/interactions.html"><strong>5.3.</strong> Interactions</a></li><li><a href="input/potentials.html"><strong>5.4.</strong> Potentials</a></li><li><a href="input/simulations.html"><strong>5.5.</strong> Simulations</a></li><li><a href="input/md.html"><strong>5.6.</strong> Molecular dynamics</a></li><li><a href="input/mc.html"><strong>5.7.</strong> Monte-Carlo</a></li></ul></li><li><strong>6.</strong> Advanced tutorials</li><li><ul class="section"><li><strong>6.1.</strong> Adding potentials</li><li><strong>6.2.</strong> Adding outputs</li><li><strong>6.3.</strong> Extending Molecular dynamics</li><li><strong>6.4.</strong> Extending Monte-Carlo</li><li><strong>6.5.</strong> Adding propagators</li></ul></li><li><a href="faq.html"><strong>7.</strong> FAQ</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>The Lumol user manual</h1>
<p>Welcome to the Lumol user manual. In this book we teach you how to use Lumol to
set up and run classical molecular simulations. We designed Lumol to be
<em>flexible</em> and <em>extensible</em>; you are able to customize your simulation to suit
your needs and use it as a platform to implement your own algorithms and
customized potential functions in an <em>easy</em> way. You can use Lumol as a command
line tool as well as a library in your own code.</p>
<p>Excited? Then let's start with an overview of this book:</p>
<ul>
<li><a href="installation.html">Installation</a>: Where to get and how to install Lumol.</li>
<li><a href="">The first simulations</a>: Step-by-step tutorials on
how to perform basic molecular dynamics and Monte-Carlo simulations.</li>
<li><a href="concepts/intro.html">Conceptual guides</a>: Learn about the details. How are
systems assembled? How do system propagators work?</li>
<li><a href="input/intro.html">Input files reference</a>: The complete reference for the
input files needed to perform simulations;</li>
<li><a href="">Advanced Tutorials</a>: Extending and customizing Lumol.</li>
</ul>
<p><strong>Note</strong>: Lumol is actively developed and should be considered as alpha software.
As the code is likely to change so is this documentation.</p>
<h2>Systems and Simulations</h2>
<p>Lumol mainly consists of two building blocks: the <code>System</code> and the <code>Simulation</code>.
The <code>System</code> contains general informations about the system, such as atomic
names, positions and velocities, force-field, simulation box. On the other hand,
a <code>Simulation</code> contains everything needed to run a simulation with a system,
<em>i.e.</em> algorithms and associated data.</p>
<p>A <code>System</code> is usually used in combination with one <code>Simulation</code> to explore the
properties of the system. Sometimes multiple systems can be associated with the
same simulation (in Gibbs ensemble Monte-Carlo or in parallel tempering); and
sometimes multiple simulations can be associated with the same system, when
running an energy minimization before a molecular dynamics run.</p>
<h1>Installation</h1>
<p>Lumol is written in <a href="https://www.rust-lang.org/">Rust</a> (<a href="faq.html#Why%20is%20Lumol%20written%20in%20Rust?">why?</a>), and you will need a Rust
compiler to compile it. You can download one from <a href="https://www.rust-lang.org/downloads.html">here</a>, or
using your package manager (Rust is available on Fedora, and with Homebrew).
Lumol also depends on some C++ libraries, so you will need a C++ compiler and
cmake to be installed.</p>
<p>Lumol is tested on Linux and OsX, and should build on Windows without any issue.
You will need a C++11 capable compiler on Windows (MSVC &gt; 15 or Mingw with gcc &gt;
4.9). Be sure to pick the corresponding version of the Rust compiler.</p>
<p>When all the dependencies are installed on you system, you can install the
latest release of Lumol using:</p>
<pre><code>cargo install lumol
</code></pre>
<p>and the latest development version with:</p>
<pre><code>cargo install --git https://github.com/lumol-org/lumol
</code></pre>
<p>Both of these commands will download and install the command line interface for
Lumol in <code>~/.cargo/bin/lumol</code>, where <code>~</code> is your home directory. You may want to
add <code>~/.cargo/bin</code> to your PATH or move the <code>lumol</code> binary in another directory
accessible in your PATH.</p>
<h1>Tutorial: using Lumol</h1>
<p>This section will teach you how to use Lumol to run basic simulations. You can
and should re-use the examples input file to run your own simulations.</p>
<h1>Monte-Carlo simulation of Argon</h1>
<p>So let's run a simulation with Lumol. The easiest system to simulate is a
Lennard-Jones fluid, which is a good model for noble gases fluids. Here we will
simulate supercritical argon using Metropolis Monte-Carlo algorithm.</p>
<p>For this simulation, you will need the initial configuration available
<a href="data/argon.xyz">here</a>. Download it and save it under the name <code>argon.xyz</code>.</p>
<p>You will also need the input file available <a href="data/argon.toml">here</a>. Save it as
<code>argon.toml</code> and place it near to <code>argon.xyz</code>. You can then run the simulation
with:</p>
<pre><code>lumol argon.toml
</code></pre>
<p>The simulation should complete in a few second (8s on my system), and produce
two files: <code>energy.dat</code> and <code>trajectory.xyz</code>.</p>
<h2>Input file anatomy</h2>
<p>The input file is written using the TOML syntax, you can learn more about this
<a href="https://github.com/toml-lang/toml">syntax here</a>. The file starts with a header declaring the version of the
input file syntax used, here the version 1:</p>
<pre><code class="language-toml">[input]
version = 1
</code></pre>
<p>Then, we declare which system we want to simulate, in the <code>systems</code> array. We
define this system using an XYZ file, and providing the unit cell size.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;argon.xyz&quot;
cell = 21.65
</code></pre>
<p>We also need to define the interactions potential between the atom in the
system, which we do in the <code>potential.pairs</code> section; using a Lennard-Jones
potentials with a cutoff distance of 10 A for all Ar-Ar pairs.</p>
<pre><code class="language-toml">[[systems.potentials.pairs]]
atoms = [&quot;Ar&quot;, &quot;Ar&quot;]
cutoff = &quot;10 A&quot;
lj = {sigma = &quot;3.4 A&quot;, epsilon = &quot;1.0 kJ/mol&quot;}
</code></pre>
<p>Then we define how we want to simulate our system. Here we need to run the
simulation for <code>100000</code> steps, and output the energy to <code>energy.dat</code> every 100
steps, and the trajectory to <code>trajectory.xyz</code> every 100 steps too.</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 100000
outputs = [
    {type = &quot;Energy&quot;, file = &quot;energy.dat&quot;, frequency = 100},
    {type = &quot;Trajectory&quot;, file = &quot;trajectory.xyz&quot;, frequency = 100}
]
</code></pre>
<p>At the end we define how we propagate the system from one step to another. Here
we are using a Monte-Carlo simulation at 500 K, and the only Monte-Carlo move is
a translation of maximum amplitude of 1 A.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;1 A&quot;},
]
</code></pre>
<p>So now we know how to run simulations of Lennard-Jones fluids. How about we add
electrostatic interactions in the next example? Say hello to <a href="tutorial/nacl.html">Sodium
Chloride</a>!</p>
<h1>Hello Sodium Chloride</h1>
<p>In this example, we will simulate a Sodium Chloride crystal, using molecular
dynamics to propagate the position throughout time. Sodium Chloride add a
challenge in simulation because each atom carry a charge. These charges interact
with a Coulomb potential which goes to zero as $1 / r$. The problem is that the
cutoff scheme used for pair potential in most molecular simulations can not be
used for anything that goes to zero slower than $1 / r^3$. So we need to use
alternate methods to compute the potential for the charges-charges interactions.</p>
<p>For this simulation, you will need the initial configuration available
<a href="data/nacl.xyz">here</a>. Download it and save it under the name <code>nacl.xyz</code>. You will
also need the input file available <a href="data/nacl.toml">here</a>. Save it as <code>nacl.toml</code> and
place it near to <code>nacl.xyz</code>. Again you can run the simulation which should
complete in a minute with:</p>
<pre><code>lumol nacl.toml
</code></pre>
<p>This run a molecular dynamics simulation of a NaCl crystal, using electrostatic
interactions between the atomic charges.</p>
<h2>The input file commented</h2>
<p>We start with the input version again:</p>
<pre><code class="language-toml">[input]
version = 1
</code></pre>
<p>Then we load the system from the <code>nacl.xyz</code> file and define the unit cell.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;nacl.xyz&quot;
cell = 22.5608
</code></pre>
<p>Here we define some global values for the interactions: setting
<code>systems.potentials.global.cutoff</code> will use the given cutoff for all the pair
interactions. The <code>systems.potentials.charges</code> section defined the atomic
charges in the system.</p>
<pre><code class="language-toml">[systems.potentials.global]
cutoff = &quot;8 A&quot;

[systems.potentials.charges]
Na = 1.0
Cl = -1.0
</code></pre>
<p>We need to define the pair interactions for all the pair combinations in the
system, <em>i.e.</em> (Na, Na); (Cl, Cl); and (Na, Cl).</p>
<pre><code class="language-toml">[[systems.potentials.pairs]]
atoms = [&quot;Na&quot;, &quot;Cl&quot;]
lj = {sigma = &quot;3.5545 A&quot;, epsilon = &quot;0.04425 kcal/mol&quot;}

[[systems.potentials.pairs]]
atoms = [&quot;Na&quot;, &quot;Na&quot;]
lj = {sigma = &quot;2.497 A&quot;, epsilon = &quot;0.07826 kcal/mol&quot;}

[[systems.potentials.pairs]]
atoms = [&quot;Cl&quot;, &quot;Cl&quot;]
lj = {sigma = &quot;4.612 A&quot;, epsilon = &quot;0.02502 kcal/mol&quot;}
</code></pre>
<p>Because our system have charges, we need to use an electrostatic potential
solver. Here we are going for the <code>Wolf</code> solver, with a cutoff of 8 A.</p>
<pre><code class="language-toml">[systems.potentials.coulomb]
wolf = {cutoff = &quot;8 A&quot;}
</code></pre>
<p>We can now define the simulation and the outputs for this simulation.</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 5000
outputs = [
    {type = &quot;Trajectory&quot;, file = &quot;trajectory.xyz&quot;, frequency = 10}
]
</code></pre>
<p>We are using here a molecular dynamics simulation of the NaCl crystal, and a
timestep of 1fs for integration.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
</code></pre>
<p>In the next example, we will see how to simulate molecules of
<a href="tutorial/water.html">water</a>.</p>
<h1>Molecular dynamics of water</h1>
<p>In this example, we will simulate a molecular liquid of high scientific
interest: water. At the same time we will learn how we can reuse a potential
definition between multiple simulations, and how we can switch the potential
definition in a simulation.</p>
<p>You will need three input files for this simulation:</p>
<ul>
<li><a href="data/water.xyz">water.xyz</a>: the initial configuration;</li>
<li><a href="data/water.toml">water.toml</a>: the simulation input;</li>
<li><a href="data/water-fSCP.toml">water-fSCP.toml</a>: the potentials definitions.</li>
</ul>
<p>The simulation run in a few minutes (up to 10), and will write the trajectory of
the system.</p>
<h1>The input files commented</h1>
<h2><code>water.toml</code> file</h2>
<p>The main input file is pretty similar to the previous examples, with two
novelties:</p>
<ul>
<li>The <code>guess_bonds = true</code> entry tell Lumol to try to guess the bonds from the
distances in the XYZ file. This is needed because we want to simulate a
molecule, but there is not bonding information inside the XYZ format. If we
used a PDB file instead, this would not be needed;</li>
<li>The <code>potentials = &quot;water-fSCP.toml&quot;</code> tell Lumol to read the potentials from
the <code>water-fSCP.toml</code> file. Using this type of input for the potentials allow
to share the same potential for multiple simulations, and to easily change
the potential used in the simulation.</li>
</ul>
<pre><code class="language-toml">[input]
version = 1

[[systems]]
file = &quot;water.xyz&quot;
cell = 28.0
guess_bonds = true
potentials = &quot;water-fSCP.toml&quot;

[[simulations]]
nsteps = 5000
outputs = [
    {type = &quot;Trajectory&quot;, file = &quot;trajectory.xyz&quot;, frequency = 10}
]

[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
</code></pre>
<h2><code>water-fSCP.toml</code> file</h2>
<p><code>water-fSCP.toml</code> is a standalone potential input file. It contains the same
data as a potential definition inside a <code>[[systems]]</code> section, but without the
<code>system.potential</code> prefix on all sections names.</p>
<p>In this input, we start by defining which version of the input format we are
using.</p>
<pre><code class="language-toml"># f-SPC model of water, using Ewald summation for electrostatics
[input]
version = 1
</code></pre>
<p>Then, we can define some global input data: the pair potential cutoff and the
atomic charges.</p>
<pre><code class="language-toml">[global]
cutoff = &quot;14 A&quot;

[charges]
O = -0.82
H = 0.41
</code></pre>
<p>The pair potential section contains the usual pairs declarations, with a few
additional options.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3.16 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}
</code></pre>
<p>We can add a <code>restriction</code> to restrict a specific pair interaction to some kind
of pairs. Here we will only account for H-H pairs inside the same molecule.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;H&quot;, &quot;H&quot;]
harmonic = {k = &quot;79.8 kcal/mol/A^2&quot;, x0 = &quot;1.633 A&quot;}
restriction = &quot;IntraMolecular&quot;
</code></pre>
<p>We can also define a non-interacting pair interaction! This is useful when some
atoms does not interact in the model we use.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;H&quot;, &quot;O&quot;]
null = {}
</code></pre>
<p>Then comes the bonds and angles definitions. These are the interactions used
between bonded particles (or angles formed by two bonds and dihedrals formed by
three bonds).</p>
<pre><code class="language-toml">[[bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1054.2 kcal/mol/A^2&quot;, x0 = &quot;1.0 A&quot;}

[[angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.9 kcal/mol/rad^2&quot;, x0 = &quot;109.5 deg&quot;}
</code></pre>
<p>Finally we specify how to compute the electrostatic interaction, this time using
the Ewald sum. We can restrict the coulombic interactions to only apply between
particles not in the same molecule using a <code>restriction</code> here too.</p>
<pre><code class="language-toml">[coulomb]
ewald = {cutoff = &quot;8.5 A&quot;, kmax = 3}
restriction = &quot;InterMolecular&quot;
</code></pre>
<h1>System</h1>
<p>A <code>System</code> contains all the data about the physical system we are simulating.
It contains four types of data:</p>
<ul>
<li>A list of <strong>Particles</strong>, which are physical objects, with a position, a
velocity, a mass and a name;</li>
<li>A list of <strong>Molecules</strong> containing information about how the particles are
bounded together;</li>
<li>An <strong>UnitCell</strong>, <em>i.e.</em> the bounding box of the simulation.</li>
<li><strong>Interactions</strong>, sometimes called a force-field.</li>
</ul>
<p><img src="static/img/system.svg#center" alt="System components" /></p>
<h2>Unit cells</h2>
<p>Lumol knows about three types of unit cells:</p>
<ul>
<li>Infinite cells do not have any boundaries, and can be used to simulate
systems in vacuum;</li>
<li>Orthorhombic cells have up to three independent lengths, and all the angles
of the cell are set to 90°;</li>
<li>Triclinic cells have 6 independent parameters: 3 lengths and 3 angles.</li>
</ul>
<p>Orthorhombic and Triclinic cells are used in combination with <a href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">periodic boundary
conditions</a> to
simulate infinite systems.</p>
<h2>Interactions</h2>
<p>Interactions associate a potential and some particles kind. Lumol provides
code for various potentials types:</p>
<ul>
<li>Non-bonding pair potentials;</li>
<li>Bonds potentials in molecules;</li>
<li>Angles potentials in molecules;</li>
<li>Dihedral angles potentials in molecules;</li>
<li>Long-ranges coulombic potentials (Ewald and Wolf methods);</li>
<li>Arbitrary external potential applying on the whole system at once.</li>
</ul>
<h1>Simulation</h1>
<p>The flow of a simulation in Lumol is represented below.</p>
<p><img src="static/img/simulation.svg#center" alt="Simulation flow graph" /></p>
<p>First, it uses a system to setup any algorithms which uses system specific
informations.</p>
<p>Then it propagate the system for one step, compute the physical properties as
needed, and output these properties to the hard drive.</p>
<p>If the simulation is finished (either the required number of steps has been
done, or come convergence criterion is reached) it returns the updated system.
If the simulation is not finished, the system is propagated for one more step.</p>
<p>While propagating the simulation, Lumol uses two type of algorithms: propagators
and output algorithms.</p>
<h2>Propagators</h2>
<p>Propagators are at the heart of a Simulation. They have the responsibility to
update the system at each simulation step. Currently, three propagators exists:
a molecular dynamics one, a Monte-Carlo one and a minimizer, for energy
minimization.</p>
<h2>Output algorithms</h2>
<p>Output algorithms have the responsibility to compute and output statistical data
about the simulated system. Temperature, energy, radial distribution functions
are some examples of output algorithms. The full list of currently implemented
output algorithms is available <a href="input/simulations.html#Outputs">here</a>.</p>
<h1>Units</h1>
<p>Lumol features a set of internal units and offers facilities to convert
from and to this set of internal units.</p>
<p>The internal unit system is the following:</p>
<ul>
<li>Angstrom (<code>A</code>) for distances;</li>
<li>Femto-second (<code>fs</code>) for time;</li>
<li>Unified atomic mass unit (<code>u</code> or <code>Da</code>) for mass;</li>
<li>Kelvin (<code>K</code>) for temperature;</li>
<li>Number of particles for quantity of matter;</li>
<li>Radian (<code>rad</code>) for angles;</li>
</ul>
<p>Any other internal unit is derived from this set:</p>
<ul>
<li>The internal unit of energy is <code>u A^2 fs^-2</code>;</li>
<li>The internal unit of force is <code>u A fs^-2</code>;</li>
<li>The internal unit of pressure is <code>u A^-1 fs^-2</code>;</li>
<li><em>etc.</em></li>
</ul>
<p>Lumol knows how to convert any value in these internal unit to others units.
The accepted units are:</p>
<table><thead><tr><td> Quantity    </td><td> Accepted units                    </td></tr></thead>
<tr><td> Distance    </td><td> A, Å, nm, pm, fm, m, bohr   </td></tr>
<tr><td> Time        </td><td> fs, ps, ns                        </td></tr>
<tr><td> Mass        </td><td> u, Da, kDa, g, kg                 </td></tr>
<tr><td> Matter      </td><td> mol                               </td></tr>
<tr><td> Angle       </td><td> rad, deg                          </td></tr>
<tr><td> Energy      </td><td> J, kJ, kcal, eV, H, Ry            </td></tr>
<tr><td> Force       </td><td> N                                 </td></tr>
<tr><td> Pressure    </td><td> Pa, kPa, MPa, bar, atm            </td></tr>
</table>
<p>In the input files, the units are specified as strings, and must be spelled
exactly as in the above table. They can be combined with other units using <code>*</code>
for multiplication, <code>/</code> for division, and  <code>^</code> for exponents. Parentheses can be
used to group sub-units together. Some valid unit strings are <code>kcal/mol</code>, <code>(J / mol) * A^-2</code>, and <code>m*fs^-1</code>.</p>
<h1>Input files</h1>
<p>An input file contains all information that you need to run a simulation.
It is usually organized in three main sections: <strong>input</strong>, <strong>systems</strong> and
<strong>simulations</strong>.</p>
<ul>
<li>The <a href="input/intro.html#Input%20metadata">input</a> section contains metadata about
the input itself (i.e. a version number).</li>
<li>The <a href="input/systems.html">systems</a> section contains information about the
intial configuration, the interactions between atoms and the simulation cell.</li>
<li>The <a href="input/simulations.html">simulations</a> section defines how your system will
propagate. You can generally choose between molecular dynamics (MD) or Monte-
Carlo (MC).</li>
</ul>
<p>Interactions (often also called <em>force field</em>) are the heart of every simulation
since they encapsulate the physical behaviour of atoms by defining how they
interact with each other. You can specify interactions within the main input
file as a part of the <code>systems</code> section, but since your system can contain a
huge number of interactions it is often more convenient to create a separate
input file. Doing so has two advantages. First, it will keep your main input
file short and readable and second, you can simply reuse your force field input
for different simulations (you can even build your own force fields library). We
talk more about standalone input files for interactions on this
<a href="input/interactions.html">page</a>.</p>
<h2>Format</h2>
<p>Lumol input files use the <a href="https://github.com/toml-lang/toml">TOML</a> format, a simple and minimalistic
configuration format based on <code>key = value</code> pairs. You can read an introduction
to the TOML format <a href="https://github.com/toml-lang/toml">here</a>.</p>
<h2>Input metadata</h2>
<p>All input files must contain an <code>[input]</code> section looking like this:</p>
<pre><code class="language-toml">[input]
version = 1
</code></pre>
<p>Introducing a <code>version</code> key helps us to make changes to the input file format
while keeping compatibility with previous formats. Please note that
Lumol is not in version 1.0 yet and we currently cannot guarantee compatibility
for input files.</p>
<h2>Units in input</h2>
<p>The unit of a value can be defined by a specific string, which will be parsed
and converted to the <a href="concepts/units.html">internal unit system</a>.
If there is no unit in the string, the internal unit for this type is used.
No consistency check is performed, and it is up to you to check the given units.</p>
<pre><code class="language-toml"># Here, 'cutoff' is a distance

# OK
cutoff = &quot;8 A&quot;
# OK, will use the internal unit of distance.
# This is not recommended. The internal unit may change, and the input convey less information
cutoff = &quot;8&quot;    
# OK, but big !
cutoff = &quot;8 km&quot;  

# OK, but probably not what you want. Will be interpreted as 8000 A
cutoff = &quot;8 ps&quot;
# invalid, 'cutoff' must be a string
cutoff = 8.0   
</code></pre>
<h1>Systems</h1>
<p>Let's talk about how you can set up your system. The system contains information
about:</p>
<ul>
<li>the configuration, i.e. the positions (and velocities) of your atoms;</li>
<li>which atoms are connected (bonded) to form molecules;</li>
<li>how atoms will interact with each othe;</li>
<li>and the simulation cell (i.e. volume).</li>
</ul>
<p>All these details are listed after the <code>[[systems]]</code> keyword. The double
brackets indicate arrays of tables in TOML. Don't get confused too much, we will
talk about these in more detail while we go through the different parts of the
input file.</p>
<h2>Setting the initial configuration</h2>
<p>A convenient way to get initial atom positions is by reading them from a
file using the <code>file</code> key:</p>
<pre><code class="language-toml">[[systems]]
file = &quot;data/water.pdb&quot;
</code></pre>
<p>Lumol will read the file to build the system accordingly. If the file is a
trajectory containing multiple steps, the first frame is used. Under the hood,
we utilize <a href="http://chemfiles.github.io/">chemfiles</a> to parse the data. You can
read about available file formats in the <a href="http://chemfiles.readthedocs.io/en/latest/formats.html">chemfiles documentation</a>.</p>
<h2>Setting the topology</h2>
<p>You might want to use simple file formats such as <code>*.xyz</code> that don't specify
bonding information. You can do that by adding the bonding information
separately from your configuration file.</p>
<ul>
<li>
<p>Use the <code>topology</code> key to provide a file containing topological details.</p>
<pre><code class="language-toml">[[systems]]
# the *.xyz format has no bonding information
file = &quot;water.xyz&quot;
# the *.pdb format specifies connections between atoms
topology = &quot;topology.pdb&quot;
</code></pre>
<p>where <code>topology.pdb</code> (here for water) may look like:</p>
<pre><code>HEADER    water
COMPND
SOURCE
HETATM    1  H    ...
HETATM    2  H    ...
HETATM    3  O    ...
CONECT    1    3
CONECT    2    3
CONECT    3    1    2
END
</code></pre>
<p>with <code>CONECT</code> entries detailing for bonding information.</p>
<p>Often, you can get ready-to-use topology files from databases or create your
own topologies. If you want to know more about the Protein Data Bank (PDB)
format have a look at the <a href="http://wwpdb.org/">PDB website</a>;</p>
</li>
<li>
<p>The second option is to use the <code>guess_bonds</code> key to utilize a distance-based
algorithm that will guess the bonds in the system. The algorithm is the same
as the one in <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>. You should always check and confirm that the
bondings guessed by the algorithm are coherent with your system.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
guess_bonds = true
</code></pre>
<p>Note that <code>guess_bonds</code> takes a boolean as argument: there are no quotation
marks around <code>true</code>. Also, TOML is case sensitive, i.e. writing
<code>guess_bonds = True</code> will throw an error.</p>
</li>
</ul>
<h2>Setting the unit cell</h2>
<p>To set up the (initial) simulation cell you use the <code>cell</code> key.
We offer three different ways to set the cell:</p>
<ul>
<li>
<p><code>cell = &lt;length&gt;</code> creates a cubic unit cell with the given side
length. <code>&lt;length&gt;</code> should be a numeric value (no quotation marks) in Angstrom.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
topology = &quot;topology.pdb&quot;
cell = 40
</code></pre>
</li>
<li>
<p><code>cell = [&lt;a&gt;, &lt;b&gt;, &lt;c&gt;]</code> creates an orthorhombic unit cell.
You should provide the lengths of the cell, <code>&lt;a&gt;</code>, <code>&lt;b&gt;</code>, and <code>&lt;c&gt;</code> as numeric
values in Angstrom.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
topology = &quot;topology.pdb&quot;
cell = [24, 24, 76]
</code></pre>
</li>
<li>
<p><code>cell = [&lt;a&gt;, &lt;b&gt;, &lt;c&gt;, &lt;alpha&gt;, &lt;beta&gt;, &lt;gamma&gt;]</code> creates a triclinic unit
cell with the given side lengths and angles. <code>&lt;a&gt;</code>, <code>&lt;b&gt;</code>, and <code>&lt;c&gt;</code>
should be numeric values in Angstrom and <code>&lt;alpha&gt;</code>, <code>&lt;beta&gt;</code>, and <code>&lt;gamma&gt;</code>
numeric values in degree.</p>
<pre><code class="language-toml">[[systems]]
file = &quot;water.xyz&quot;
topology = &quot;topology.pdb&quot;
cell = [24., 24., 22., 90., 82.33, 110.4]
</code></pre>
<p>Note that in an TOML array, all values have to have the same type.
<code>cell = [24, 24, 76]</code> will work since we use all integer values, while
<code>cell = [24., 24., 76]</code> will throw an error.</p>
</li>
</ul>
<h2>Initializing velocities</h2>
<p>For molecular dynamics (MD) simulations you need initial positions and initial
velocities of all atoms in your system. Use the <code>velocities</code> key to initialize
the velocities in the following way:</p>
<pre><code class="language-toml">[[systems]]
file = &quot;data/water.xyz&quot;
topology = &quot;topology.pdb&quot;
velocities = {init = &quot;300 K&quot;}
</code></pre>
<p>where the <code>init</code> key will take the temperature as <em>string</em>. The velocities will
be initialized from a Boltzmann distribution at the given temperature.
Monte-Carlo simulations will not make any use of velocities since transition
probabilities (i.e. how the system evolves) are based on the positions (and the
underlying interactions) only.</p>
<h2>Specifying interactions</h2>
<p>Interactions between atoms are formulated via potentials; functions that give us
information about energies and forces acting between atoms. We distinguish
between <em>inter</em>- and <em>intramolecular</em> potentials. For an overview of available
potential functions, have a look at [here][potentials].</p>
<p>You can specify interactions between atoms in two ways: either inside the main
input file or in a separate file. As example we will use a flexible SPC water
model and put it directly into our main input file:</p>
<pre><code class="language-toml"># system configuration: initial positions, topology and cell
[[systems]]
file = &quot;data/water.xyz&quot;
topology = &quot;topology.pdb&quot;
cell = 40

# intermolecular potentials
[[systems.potentials.pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3.165 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}

[[systems.potentials.pairs]]
atoms = [&quot;H&quot;, &quot;H&quot;]
null = {}

[[systems.potentials.pairs]]
atoms = [&quot;O&quot;, &quot;H&quot;]
null = {}

# intramolecular potentials
[[systems.potentials.bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1059.162 kcal/mol/A^2&quot;, x0 = &quot;1.012 A&quot;}

[[systems.potentials.angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.90 kcal/mol/deg^2&quot;, x0 = &quot;113.24 deg&quot;}

# additional interactions omitted
</code></pre>
<p>As you can see, there is a lot of bracket notation going on here. First, in
<code>[[systems.potentials.xxx]]</code>, the <code>potentials</code> key is actually a nested table of
<code>systems</code> indicated by the dot notation. Accordingly, <code>pairs</code>, <code>bonds</code>,
<code>angles</code>, etc. are nested tables of <code>potentials</code>. Second, <code>harmonic = {k = &quot;75.90 kcal/mol/deg&quot;, x0 = &quot;113.24 deg&quot;}</code> is the notation for an inline table.</p>
<p>Input files can get very big and hard to read when you simulate complex systems
with a large number of different atoms. In these scenarios it may be better to
define a separate input file for your interactions like so:</p>
<pre><code class="language-toml">[[systems]]
file = &quot;data/water.xyz&quot;
topology = &quot;topology.pdb&quot;
cell = 40
potentials = &quot;water.toml&quot;
</code></pre>
<p>Here, the <code>potentials</code> key contains a string that is interpreted as the path to
another input file containing only definitions of interactions. We will give
examples of interaction input files <a href="input/interactions.html">here</a> along with available
keywords.</p>
<h1>Interactions</h1>
<p>Interactions describe the energies between atoms - or more general - between
interaction sites. These energies arrise due to covalent bonding of atoms to
form molecules,  short-range van der Waals or long-range coulombic energies. To
describe interactions we use <em>potentials</em> which are functions  that take a set
of parameters and geometrical coordinates (for example distances  or angles) as
input and yield energies and forces. A set of potential functions  and
parameters to describe energies and forces of a molecule is also often called
<em>force field</em>. We will use the terms interactions and force field
interchangeably.</p>
<p>To be more specific, we distinguish between the following contributions:</p>
<ul>
<li><code>pairs</code> are van der Waals interactions between pairs of atoms,</li>
<li><code>bonds</code> describe the energy between covalently bonded atoms,</li>
<li><code>angles</code> and <code>dihedrals</code> describe energy contributions due to bending and
twisting of covalently bonded atoms,</li>
<li><code>coulomb</code> and <code>charges</code> describe long-range contributions due to electrostatic
interactions.</li>
</ul>
<p>Information about interactions for <code>pairs</code>, <code>bonds</code>, <code>angles</code> and <code>dihedrals</code>
are organised as arrays of TOML tables. The <code>coulomb</code> section contains
information about the treatment of long-range electrostatic interactions and the
<code>charges</code> section defines the partial charges of the atoms.</p>
<p>An example of an input file for the f-SPC model of water is given bellow:</p>
<pre><code class="language-toml">[input]
version = 1

[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3.16 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}

[[pairs]]
atoms = [&quot;O&quot;, &quot;H&quot;]
null = {}

[[pairs]]
atoms = [&quot;H&quot;, &quot;H&quot;]
harmonic = {k = &quot;79.8 kcal/mol/A^2&quot;, x0 = &quot;1.633 A&quot;}
restriction = &quot;intra-molecular&quot;

[[bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1054.2 kcal/mol/A^2&quot;, x0 = &quot;1.0 A&quot;}

[[angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.9 kcal/mol/rad^2&quot;, x0 = &quot;109.5 deg&quot;}

[coulomb]
ewald = {cutoff = &quot;10 A&quot;, kmax = 7}

[charges]
O = -0.82
H = 0.41
</code></pre>
<h2>van der Waals and covalent interactions</h2>
<p>The <code>pairs</code>, <code>bonds</code>, <code>angles</code> and <code>dihedrals</code> sections are arrays, in which
every entry must contain at least two keys: the <code>atoms</code> key, and a
<a href="input/potentials.html#Available%20potentials">potential</a> key. With the <code>atoms</code>
key you can specify the two atom types to which the interaction should be
applied. The number of atoms depends on the type of interaction: You have to
provide two atoms for <code>pairs</code> and <code>bonds</code>, three atoms for <code>angles</code> and four
atoms for <code>dihedrals</code>.</p>
<p>For example you can use a <code>harmonic</code> bond potential for all your <code>C-H</code> bonds:</p>
<pre><code class="language-toml">[[bonds]]
atoms = [&quot;C&quot;, &quot;H&quot;]
harmonic = {x0 = &quot;3.405 A&quot;, k = &quot;2385 kcal/mol/A^2&quot;}
</code></pre>
<h3>Restrictions</h3>
<p>In some force fields, neighbouring atoms in molecules may interact solely via
covalent potentials (and not van der Waals or electrostatic). In this case, we
have to <em>exclude</em> interactions between neighbours in molecules. You can do that
(and more) in the <code>pairs</code> section by specifying a
<a href="input/potentials.html#Restrictions">restriction</a> using the <code>restriction</code> key.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;Ar&quot;, &quot;Ar&quot;]
lj = {sigma = &quot;3.405 A&quot;, epsilon = &quot;0.2385 kcal/mol&quot;}
restriction  = &quot;IntraMolecular&quot;
</code></pre>
<h2>Coulombic interactions</h2>
<p>The method for treatment of electrostatic interactions is specified in the
<code>coulomb</code> section. There are multiple available solvers for <a href="input/potentials.html#Electrostatic%20interactions">electrostatic
interactions</a>. Optionally,
an additional <a href="input/potentials.html#Restrictions">restriction</a> can be specified
with the <code>restriction</code> key.</p>
<pre><code class="language-toml">[coulomb]
ewald = {cutoff = &quot;10 A&quot;, kmax = 7}
restriction  = &quot;exclude13&quot;

[charges]
Na = 1
Cl = -1
</code></pre>
<h1>Available potentials</h1>
<p>This section is a list of all the available potentials in Lumol, with the
associated parameters. All potentials have to provide additional parameters in
there definition, as a TOML table. Using inline tables is the easiest way to do
so:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;A&quot;, &quot;B&quot;]
# Additional parameters here are 'sigma' and 'epsilon'.
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
</code></pre>
<p>The same potential can be used for either pairs (at distance $r$); or for
angles (at angle $\phi$). In all the formulas, the $x$ parameter
represents either a distance or an angle.</p>
<h2>Null potential</h2>
<p>This potential is always 0, for all values of $x$. It should be used to remove
interactions between atoms in a pair/bond/angle/dihedral that are
present in the system but should not be interacting.</p>
<p>This potential can be used by specifying the <code>null</code> key with an empty table <code>{}</code>
as value.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
null = {}
</code></pre>
<h2>Lennard-Jones potential</h2>
<p>The Lennard-Jones potential is a classical potential for pair interactions
expressed as: $$ V(x) = 4 \epsilon \left[\left(\frac{\sigma}{x}\right)^{12} -
\left(\frac{\sigma}{x}\right)^6\right].$$</p>
<p>The Lennard-Jones potential is defined using the <code>lj</code> or <code>lennardjones</code> key. The
parameters are <code>sigma</code> ($\sigma$) and <code>epsilon</code> ($\epsilon$), which should be
provided as strings.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lennardjones = {sigma = &quot;3.16 A&quot;, epsilon = &quot;0.155 kcal/mol&quot;}
</code></pre>
<h2>Harmonic potential</h2>
<p>The Harmonic potential is usually used for intramolecular interactions such as
bonds, angles or dihedrals. It is expressed as:
$$ V(x) = \frac 12 k \ (x - x_0)^2$$</p>
<p>The potential type keyword is <code>harmonic</code>, and the parameters are <code>k</code> and <code>x0</code>,
provided as strings.</p>
<pre><code class="language-toml">[[bonds]]
atoms = [&quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;1054.2 kcal/mol/A^2&quot;, x0 = &quot;1.0 A&quot;}

[[angles]]
atoms = [&quot;H&quot;, &quot;O&quot;, &quot;H&quot;]
harmonic = {k = &quot;75.9 kcal/mol/rad^2&quot;, x0 = &quot;109.5 deg&quot;}
</code></pre>
<h2>Cosine-Harmonic potential</h2>
<p>This potential is usually used for angles and dihedral angles interactions,
because it presents a $2\pi$ periodicity. It is expressed as: $$ V(x) = \frac 12
k \ (\cos x - \cos x_0)^2$$</p>
<p>The potential type keyword is <code>cosine-harmonic</code>, and the parameters <code>k</code> and <code>x0</code>
should be provided as strings.</p>
<pre><code class="language-toml">[[angles]]
atoms = [&quot;H&quot;, &quot;C&quot;, &quot;H&quot;]
cosine-harmonic = {k = &quot;67 kJ/mol&quot;, x0 = &quot;120 deg&quot;}
</code></pre>
<h2>Torsion potential</h2>
<p>This potential is usually used for dihedral interactions. It is
expressed as: $$ V(x) = k \ (1 + \cos(n x - \delta))$$</p>
<p>The potential type keyword is <code>torsion</code>, and the parameters <code>k</code> and <code>delta</code>
($\delta$) should be provided as strings, and <code>n</code> should be provided as an
integer.</p>
<pre><code class="language-toml">[[dihedrals]]
atoms = [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;]
torsion = {k = &quot;40 kJ/mol&quot;, delta = &quot;120 deg&quot;, n: 4}
</code></pre>
<h1>Electrostatic interactions</h1>
<p>When some particles in a system are charged, they interact with a Coulomb
potential: $$ V(x) = \frac{Z_i Z_j}{4 \pi \epsilon r_{ij}}, $$ where $Z_{i,j}$
are the net charges of the particles, $r_{ij}$ the distance between them and
$\epsilon$ the dielectric permittivity of the current medium (usually the one of
void). Because this potential goes to zero at infinity slower than $1/r^3$, it
can not be computed in periodic simulations using a cutoff distance. This
section present the available solvers for electrostatic interactions.</p>
<p>In the input files, electrostatic interactions are specified with two sections:
the <code>[charges]</code> section set the values of the charges of the atoms in the
system, and the <code>[coulomb]</code> section set the solver to use for the interaction.</p>
<h2>Charge section</h2>
<p>Charges for the particles in the system are set in a <code>[charges]</code> section in the
potential input file. This section should contains multiple <code>name = &lt;charge&gt;</code>
entries, one for each charged particle in the system.</p>
<pre><code class="language-toml"># Some salt here
[charges]
Na = 1
Cl = -1
</code></pre>
<h2>Ewald solver</h2>
<p>Ewald idea for computing the electrostatic interactions is to split the
interaction in a short-range term which can be handled with a cutoff scheme; and
a long range term that ca be computed by using a <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier
transform</a>. For more
information about the Ewald summation and its variants, see
<a href="http://dx.doi.org/10.1063/1.881812">[Frenkel2002]</a>.</p>
<p>The <code>[coulomb]</code> section for using an Ewald solver looks like this in the input
file:</p>
<pre><code class="language-toml">[coulomb]
ewald = {cutoff = &quot;9 A&quot;, kmax = 7}
</code></pre>
<p>The <code>cutoff</code> parameter specify the cutoff distance for the short-range and
long-range interactions splitting. The <code>kmax</code> parameter give the number of
vector to use in the reciprocal space (the long-range part of interactions).
Usually 7-8 is a good value for pure water, for very periodic charges a lower
value like 5 can do it, and for more heterogeneous system, higher values of
<code>kmax</code> are needed.</p>
<h2>Wolf solver</h2>
<p>Wolf method is another method for computing electrostatic interactions presented
in <a href="http://dx.doi.org/10.1063/1.478738">[Wolf1999]</a>. This method replaces the
expensive computation in reciprocal space from Ewald by a corrective term, and
can be expressed as a converging sum over the charged pairs in the system.</p>
<p>It is accessible with the <code>wolf</code> keyword in the input files:</p>
<pre><code class="language-toml">[coulomb]
wolf = {cutoff = &quot;11 A&quot;}
</code></pre>
<p>The only parameter is a <code>cutoff</code>, which should be taken bigger than the
corresponding Ewald cutoff. A value of 10 A is a good one in pure water.</p>
<h1>Restrictions</h1>
<p>Some force fields define additional restrictions concerning which particles
should interact together. For example, sometimes bonded particles should not
interact through electrostatic potential, or some interactions should only be
taken in account for particles not in the same molecule. The way to specify this
is to use restrictions. Restrictions can be used in two places: in the
<code>[[pairs]]</code> section, and in the <code>[coulomb]</code> section. In both cases, they are
specified with the <code>restriction</code> keyword, and one of the possible values.</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
restriction = {scale14 = 0.5}

[coulomb]
ewald = {cutoff = &quot;8 A&quot;, kmax = 6}
restriction = &quot;intermolecular&quot;
</code></pre>
<p>The possible values for <code>restriction</code> are:</p>
<ul>
<li><code>&quot;intramolecular&quot;</code> or <code>&quot;intra-molecular&quot;</code> to restrict the potential to only
particles in the same molecule;</li>
<li><code>&quot;intermolecular&quot;</code> or <code>&quot;inter-molecular&quot;</code> to restrict the potential to only
particles NOT in the same molecule;</li>
<li><code>&quot;exclude12&quot;</code> to exclude particles directly bonded together;</li>
<li><code>&quot;exclude13&quot;</code> to exclude particles directly bonded together or forming an
angle;</li>
<li><code>&quot;exclude14&quot;</code> to exclude particles directly bonded together; forming an angle
or a dihedral angle;</li>
<li><code>{scale14 = &lt;scaling&gt;}</code> to exclude particles directly bonded together or
forming an angle and to scale interaction between particles at 3 bonds of
distance by the given <code>scaling</code> factor. The factor must be between 0 and 1.</li>
</ul>
<h1>Potential computations</h1>
<p>The same potential function (Lennard-Jones, Harmonic, <em>etc.</em>) can be computed
with different method: directly, by sifting it at the cutoff distance, using a
table interpolation, <em>etc.</em> This is the purpose of computation. The default way
is to use the mathematical function corresponding to a potential to compute it.
To use another computation, the <code>computation</code> keyword can be used in the
<code>[[pairs]]</code> section.</p>
<h2>Cutoff computation</h2>
<p>It is possible to use a cutoff radius $rc$ to compute a potential $U(r)$ such
that:</p>
<p>$$ V(r) = \begin{cases}
U(r) - U(rc) &amp; r &lt;= rc \\
0 &amp; r &gt; rc
\end{cases}$$</p>
<p>The potential $U$ is additionally shifted to make sure it is continuous at $r =
rc$. This is important for molecular dynamics, where a discontinuity means an
infinite force in the integration. You can choose the <code>cutoff</code> value in the
input:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
computation = {cutoff = &quot;8 A&quot;}
</code></pre>
<h2>Table interpolation</h2>
<p>Another way to compute a potential is to pre-compute it on a regularly spaced
grid, and then to interpolate values for points in the grid. In some cases, this
can be faster than recomputing the function every time.</p>
<p>This can be done with the <code>table</code> computation, which does a linear interpolation
in regularly spaced values in the <code>[0, max)</code> segment. You need to provide the
<code>max</code> value, and the number of points <code>n</code> for the interpolation:</p>
<pre><code class="language-toml">[[pairs]]
atoms = [&quot;O&quot;, &quot;O&quot;]
lj = {sigma = &quot;3 A&quot;, epsilon = &quot;123 kJ/mol&quot;}
computation = {table = {max = &quot;8 A&quot;, n = 5000}}
</code></pre>
<hr />
<p>[Frenkel2002] Frenkel, D. &amp; Smit, B. <em>Understanding molecular simulation.</em>
(Academic press, 2002).</p>
<p>[Wolf1999] Wolf, D., Keblinski, P., Phillpot, S. R. &amp; Eggebrecht, J. <em>Exact
method for the simulation of Coulombic systems by spherically truncated,
pairwise 1/r summation.</em> The Journal of Chemical Physics <strong>110</strong>, 8254 (1999).</p>
<h1>Simulations</h1>
<p>The way to propagate the system is defined in the <code>[[simulations]]</code> section of
the input file. This section always contains at least two keys: <code>nsteps</code> specify
the number of steps in the simulation, and the <code>simulations.propagator</code> table
specify which propagator to use.</p>
<p>Here is an example of NPT molecular dynamics:</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000

[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>Two propagators are currently implemented: one for <a href="input/md.html">molecular dynamics</a>; and
one for <a href="input/mc.html">Monte-Carlo</a>.</p>
<h2>Outputs</h2>
<p>Additionally, a simulation can also output the evolution of the system
properties. Which properties are needed is given in the <code>outputs</code> array:</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000
outputs = [
    {type = &quot;Trajectory&quot;, file = &quot;filename.xyz&quot;, frequency = 100},
    {type = &quot;Energy&quot;, file = &quot;energy.dat&quot;, frequency = 200}
]

[simulations.propagator]
...
</code></pre>
<p>This array is an array of tables, containing three keys: the <code>type</code> of output,
the <code>file</code> to write the output to; and the <code>frequency</code> of the output. The file
is a path, and the output will be written to this path. The frequency is a
number, and the output will be written every <code>frequency</code> steps to the file.
Except for the <code>Trajectory</code> output, all files are formatted with header lines
starting with a <code>#</code>, and containing information about the quantities and the
units used for the output, and then multiple lines containing the step and the
quantities. The available outputs are the following:</p>
<ul>
<li>The <code>Energy</code> output will write the potential, kinetic and total energy;</li>
<li>The <code>Cell</code> output will write the unit cell parameters, lengths and angles;</li>
<li>The <code>Properties</code> output will write the volume, the instant pressure (computed
from the virial equation) and the instant temperature of the system;</li>
<li>The <code>Trajectory</code> output should be used to write a trajectory. The format of
the trajectory will be guessed from the <code>file</code> extension. Supported formats
are documented in <a href="http://chemfiles.github.io/chemfiles/">chemfiles</a>
documentation.</li>
</ul>
<h1>Molecular dynamics</h1>
<p>A molecular dynamics simulation is started by setting the propagator <code>type</code> to
<code>&quot;MolecularDynamics&quot;</code>. The only needed key is the <code>timestep</code>, which is the
time step to use in the integration of forces and velocities to positions.</p>
<pre><code class="language-toml">[[simulations]]
nsteps = 1_000_000

[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>Other options are the <code>integrator</code> key to use another integration scheme, the
<code>thermostat</code> key to set a thermostat, and the <code>controls</code> key to add some
additional control algorithm to the simulation.</p>
<h2>Integrators</h2>
<p>Integrators are algorithms that propagate the forces acting on the particles to
compute their motions. The simplest ones performs an NVE integration, but some
integrators allow to work in different ensembles. All NVE integrators can be
turned into NVT integrators by adding a <a href="input/md.html#Thermostats">thermostat</a>
to the simulation. In the input, if the <code>integrator</code> key is absent, the default
integrator is a Velocity-Verlet integrator.</p>
<h3>Velocity-Verlet integrator</h3>
<p>Velocity-Verlet is the most common NVE integrator for molecular dynamics. See
this <a href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">page</a> for more informations about the algorithm.</p>
<p>In the input, it can be specified by using the <code>VelocityVerlet</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;VelocityVerlet&quot;}
</code></pre>
<h3>Verlet integrator</h3>
<p>Verlet algorithm is another simple NVE integrator. See this <a href="https://en.wikipedia.org/wiki/Verlet_integration#Basic_St.C3.B6rmer.E2.80.93Verlet">page</a> for
more informations. Most of the time, the Velocity-Verlet algorithm is
preferable, since it produces more precise velocities.</p>
<p>In the input, it can be specified by using the <code>Verlet</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;Verlet&quot;}
</code></pre>
<h3>Leap-Frog integrator</h3>
<p>The Leap-Frog algorithm is a third NVE integrator. See this <a href="https://en.wikipedia.org/wiki/Leapfrog_integration">page</a> for
details about the algorithm.</p>
<p>In the input, it can be specified by using the <code>LeapFrog</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;LeapFrog&quot;}
</code></pre>
<h3>Berendsen barostat</h3>
<p>The Berendsen barostat integrator algorithm use the Berendsen barostat with a
Velocity-Verlet integrator to achieve NPT integration. It must be use together
with a thermostat, preferentially the Berendsen thermostat. See this
<a href="http://www.sklogwiki.org/SklogWiki/index.php/Berendsen_barostat">page</a> for more informations about the algorithm.</p>
<p>This algorithm exists in two versions: an isotropic one and an anisotropic one.
The isotropic version of the barostat scale all the cell parameter by the same
value using the scalar pressure. The anisotropic version scale the different
cell parameters by different values, using the stress tensor instead.</p>
<p>In the input, the isotropic barostat can be specified by using the
<code>BerendsenBarostat</code> integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;BerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The <code>pressure</code> key specify the target pressure for the simulation, and the
<code>timestep</code> is the relaxation time step of the barostat.</p>
<p>The anisotropic barostat can be specified by using the <code>AnisoBerendsenBarostat</code>
integrator type:</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
integrator = {type = &quot;AnisoBerendsenBarostat&quot;, pressure = &quot;100 bar&quot;, timestep = 1000}
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The <code>pressure</code> key specify the target hydrostatic pressure for the simulation,
and the <code>timestep</code> is the relaxation time step of the barostat.</p>
<p>In both cases, the barostat time step is expressed in fraction of the main
integration time step. Using a main time step of 2 fs and a barostat time step
of 1000 will yield an effective relaxation time of 2000 fs or 2 ps.</p>
<h2>Thermostats</h2>
<p>Thermostats are algorithms used to maintain the temperature of a system at a
given value. They are specified in the input by the <code>thermostat</code> key.</p>
<h3>Berendsen thermostat</h3>
<p>The Berendsen barostat is described <a href="http://www.sklogwiki.org/SklogWiki/index.php/Berendsen_thermostat">here</a>, and provide a
simple exponential relaxation of the temperature to a target value. In the
input, it is declared with the <code>Berendsen</code> thermostat type, a target
<code>temperature</code> value, and a <code>timestep</code>.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
thermostat = {type = &quot;Berendsen&quot;, temperature = &quot;400 K&quot;, timestep = 100}
</code></pre>
<p>The time step is expressed in fraction of the main integration time step, like
for the Berendsen barostat.</p>
<h3>Rescaling thermostat</h3>
<p>A rescaling thermostat is the simplest thermostating algorithm possible: it just
rescale all the velocities to set the temperature to the wanted value. It can be
useful for equilibrations, for a fast convergence. In the input, it is specified
by the <code>Rescale</code> thermostat type, a target <code>temperature</code> value, and a
<code>tolerance</code> value. The tolerance value is optional, and is used to let the
system fluctuate around the wanted temperature: while the instant temperature is
inside the <code>[temperature - tolerance : temperature + tolerance]</code> range, no
rescale happen.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
thermostat = {type = &quot;Rescale&quot;, temperature = &quot;250 K&quot;, tolerance = &quot;10 K&quot;}
</code></pre>
<h2>Controls</h2>
<p>Control algorithm are supplementary steps that modify the system to ensure some
invariant, or apply some constraint. They are specified in the <code>controls</code> array,
by giving a control <code>type</code>.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MolecularDynamics&quot;
timestep = &quot;1 fs&quot;
controls = [
    {type = &quot;RemoveRotation&quot;}
]
</code></pre>
<ul>
<li>The <code>RemoveTranslation</code> control remove the global system rotation;</li>
<li>The <code>RemoveRotation</code> control remove the global system translation.</li>
</ul>
<h1>Monte-Carlo</h1>
<p>A Monte-Carlo simulation is started by setting the propagator <code>type</code> to
<code>MonteCarlo</code>. The two needed keys are the <code>temperature</code> of the simulation, and
the Monte-Carlo <code>moves</code> to use.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;1 A&quot;, frequency = 2},
    {type = &quot;Rotate&quot;, delta = &quot;20 deg&quot;, molecule = &quot;CO2.xyz&quot;},
]
</code></pre>
<h2>Moves</h2>
<p>All the Monte-Carlo moves are specified as inline tables, with the <code>type</code> key
setting the type of move. They all accept an optional <code>frequency</code> value setting
at which frequency the move should be selected. By default the frequency is 1,
and the actual frequency will be the <code>frequency</code> value diveded by the sum of all
the frequencies.</p>
<p>Some moves acting a single molecule also accept a <code>molecule</code> key, giving the
path to a file which <a href="chemfiles.github.io">chemfiles</a> can read. The molecule associated
with the move will then be selected with the following algorithm:</p>
<ul>
<li>Read the first frame of the file;</li>
<li>If the file does not contain any bonding informations, try to guess the bonds;</li>
<li>Use the first molecule of the frame.</li>
</ul>
<p>The same move type can be present more than once in the input, to have different
amplitudes for different compounds for example.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;2 A&quot;, molecule = &quot;H2O.xyz&quot;},
    {type = &quot;Translate&quot;, delta = &quot;0.5 A&quot;, molecule = &quot;protein.pdb&quot;},
]
</code></pre>
<h3>Translation</h3>
<p>The <code>Translate</code> move type will do small translations of a single molecule at the
time. If the input contains the <code>molecule</code> key, the move will only apply to one
molecule. If not, the move will apply to all molecules in the system. The
<code>delta</code> key gives the amplitude of the translations, in distance unit.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Translate&quot;, delta = &quot;1 A&quot;, frequency = 2},
    {type = &quot;Translate&quot;, delta = &quot;10 A&quot;, molecule = &quot;He.xyz&quot;},
]
</code></pre>
<h3>Rotation</h3>
<p>The <code>Rotate</code> move type will do small rotations of a single molecule at the
time. If the input contains the <code>molecule</code> key, the move will only apply to one
molecule. If not, the move will apply to all molecules in the system. The
<code>delta</code> key gives the amplitude of the rotations, in angle unit.</p>
<pre><code class="language-toml">[simulations.propagator]
type = &quot;MonteCarlo&quot;
temperature = &quot;500 K&quot;
moves = [
    {type = &quot;Rotate&quot;, delta = &quot;3 deg&quot;, frequency = 2},
]
</code></pre>
<h1>FAQ</h1>
<p>Here are some commons questions about Lumol. If you have more questions, please
contact us on <a href="https://gitter.im/lumol-org/lumol">Gitter</a> to ask it, so that we can add it here!</p>
<h2>Is there any graphical interface to Lumol?</h2>
<p>Unfortunately, no. But because Lumol is built around a core library implementing
all the simulation algorithms, it should be easier to create a graphical
interface around it. If you are interested in a graphical user interface (using
it or building it), please contact us!</p>
<h2>What kind of simulation can I run with Lumol?</h2>
<p>You should be able to run any kind of classical simulation, from 2 atom up to as
atoms fits in your computer memory. Lumol try very hard not to be biased toward
some systems, and is as flexible as possible.</p>
<h2>How can I build the initial configuration?</h2>
<p>Lumol do not provide tools for building the initial simulation configuration.
There are already a lot of very good tools around, that you can use. Examples
include <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>, <a href="http://www.ime.unicamp.br/%7Emartinez/packmol/">packmol</a>, <a href="http://gromacs.org/">gromacs</a>, and many others.</p>
<h2>Is the code parallel? If so, how well does it scale?</h2>
<p>The code is currently exclusively running in serial mode. But is it written in
such a way porting it to use parallel algorithms should be very easy. If you
have trivially parallel computations to run (running the same simulation on
multiple systems, or on the same system but changing parameters; parallel
tempering); you should already be able to assemble the building block in Lumol
to run it. The usage of Rust guarantee us that the code is data-race free.</p>
<h2>Why should I use Lumol?</h2>
<p>If any of these statement is true for you, you should consider using Lumol:</p>
<ul>
<li>You need to use a specific potential that is not yet available in other
codes, or develop your own potential. Adding a new potential in Lumol is very
simple and take less than 20 lines of code;</li>
<li>You are developing new simulation algorithms, for example more efficient
free-energy computations or better parallel scaling of Coulomb computations.
Lumol allow you to write the specific algorithm, and reuse all the other part
of the simulation engine;</li>
<li>You are developing new simulation algorithms, for more efficient free-energy
computations or better parallel scaling of Coulomb computations. Lumol allow
you to write the specific algorithm, and reuse all the other part of the
simulation engine;</li>
</ul>
<p>Other nice goodies include:</p>
<ul>
<li>Nicely formatted and easy to read input files;</li>
<li><em>(and more to come ...)</em></li>
</ul>
<h2>Why should I NOT use Lumol?</h2>
<p>Here are some reasons for you not to use Lumol:</p>
<ul>
<li>You need to get the fastest code for your simulations because you are working
with a lot of atoms. Lumol is relatively young and is not yet fully optimized;</li>
<li>You need to scale on a lot of processors, to make your computations faster.
Lumol is <a href="faq.html#Is%20the%20code%20parallel?%20If%20so,%20how%20well%20does%20it%20scale?">not yet parallel</a>, and will be made so, but you should
continue to use other codes in the meantime.</li>
</ul>
<h2>Why is Lumol written in Rust?</h2>
<p><a href="http://www.rust-lang.org/">Rust</a> is a language created by Mozilla, and was released in 1.0 version
in may 2015. It is a modern language, that provides the same access to the bare
metal performances as C or C++, but prevents some programmer mistakes leading to
crashes and corruptions.</p>
<p>This allow to build better software faster, because the programmer does not need
to spend as much time debugging the code. At the same time, it also allow to
check at compile-time that a code is data-race free, and allow to build parallel
programs more easily.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
